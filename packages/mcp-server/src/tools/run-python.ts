import { withLogging } from "../utils.js";
import { config } from "../config.js";
import { Gbox } from "../service/index.js";
import { z } from "zod";
import type { Logger } from '../mcp-logger.js';

export const RUN_PYTHON_TOOL = "run-python";
export const RUN_PYTHON_DESCRIPTION = `Run Python code in a sandbox. 
The Python image comes with uv package manager pre-installed and pip is not available. 
The following Python packages are pre-installed: numpy, scipy, pandas, scikit-learn, requests, beautifulsoup4, pillow, matplotlib.
To install additional Python packages, use run-bash tool to execute 'uv pip install --system' as virtual environments are not yet supported.
The default working directory is /var/gbox.
To persist files after sandbox reclamation, save them to /var/gbox/share directory. 
Files in this directory will be retained for a period of time after the sandbox is reclaimed.

To read files generated by your program, use the read-file tool with the boxId returned from this tool.`;

export const runPythonParams = {
  code: z.string().describe(`The Python code to run. This code will be executed through the Python interpreter directly and will not be saved to a file.`),
  boxId: z.string().optional().nullable()
    .describe(`The ID of an existing box to run the code in.
      If not provided, the system will try to reuse an existing box with matching image.
      The system will first try to use a running box, then a stopped box (which will be started), and finally create a new one if needed.
      Note that without boxId, multiple calls may use different boxes even if they exist.
      If you need to ensure multiple calls use the same box, you must provide a boxId.
      You can get the list of existing boxes by using the list-boxes tool.
      `),
};

export const handleRunPython = withLogging(
  async (logger: Logger, { boxId, code }, { signal, sessionId }) => {
    const gbox = new Gbox();

    logger.info(
      `Executing Python code in box: ${boxId || "new box"} ${
        sessionId ? `for session: ${sessionId}` : ""
      }`
    );

    // Get or create box
    const result = await gbox.boxes.getOrCreateBox({
      boxId,
      image: config.images.playwright,
      sessionId,
      signal,
    });

    // Check if image is being pulled
    if (result.imagePullStatus?.inProgress) {
      return {
        content: [
          {
            type: "text" as const,
            text: JSON.stringify({
              status: "image_pulling",
              message: result.imagePullStatus.message,
              imageName: result.imagePullStatus.imageName
            }, null, 2),
          },
        ],
      };
    }

    // Ensure we have a valid boxId
    if (!result.boxId) {
      logger.error("Failed to get or create box");
      return {
        content: [
          {
            type: "text" as const,
            text: JSON.stringify({
              status: "error",
              message: "Failed to get or create box"
            }, null, 2),
          },
        ],
      };
    }

    // Run command
    const runResult = await gbox.boxes.runInBox(
      result.boxId,
      ["python3"],
      code,
      100, // stdoutLineLimit
      100, // stderrLineLimit
      { signal, sessionId }
    );

    logger.info("Python code executed successfully");
    if (!runResult.stderr && !runResult.stdout) {
      runResult.stdout = "[No output]";
    }
    return {
      content: [
        {
          type: "text" as const,
          text: JSON.stringify(runResult, null, 2),
        },
      ],
    };
  }
);
