#!/usr/bin/env expect

# Exit codes:
#   0 - Test passed
#   1 - Test failed

# Set timeout for command execution
set timeout 30

# Colors for output
set GREEN "\033\[0;32m"
set RED "\033\[0;31m"
set YELLOW "\033\[1;33m"
set BLUE "\033\[0;34m"
set NC "\033\[0m"

# Get the gbox binary path
# Default to using the built binary in the parent directory
set gbox_binary "../gbox"

# If the built binary doesn't exist, fall back to system gbox
if {![file exists $gbox_binary]} {
    set gbox_binary "gbox"
}

puts "${BLUE}Testing gbox box cp command...${NC}"

# First, create a test box for our cp tests
puts "\n${YELLOW}Creating a test box for cp tests...${NC}"
set test_box_id ""
if {[catch {
    spawn $gbox_binary box create linux
    expect {
        -re "Linux box created with ID: (\[a-f0-9-]+)" {
            set test_box_id $expect_out(1,string)
            puts "${GREEN}✓ Test box created with ID: $test_box_id${NC}"
            exp_continue
        }
        -re "Linux box created successfully" {
            puts "${GREEN}✓ Test box created successfully (no ID returned)${NC}"
            # If no ID is returned, we'll use a placeholder
            set test_box_id "test-box-placeholder"
            exp_continue
        }
        -re "failed to create Linux box" {
            puts "${YELLOW}⚠ Failed to create test box (API not available), using placeholder ID${NC}"
            set test_box_id "test-box-placeholder"
            exp_continue
        }
        timeout {
            puts "${RED}✗ Timeout waiting for box creation${NC}"
            set test_box_id "test-box-placeholder"
            exp_continue
        }
        eof {
            puts "${GREEN}✓ Box create command completed${NC}"
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Box creation failed: $result${NC}"
    set test_box_id "test-box-placeholder"
}

if {$test_box_id == ""} {
    set test_box_id "test-box-placeholder"
}

# Test 1: Basic box cp command without arguments (should show error)
puts "\n${YELLOW}Testing basic box cp command without arguments...${NC}"
puts "${BLUE}Running Test 1: Basic box cp command without arguments${NC}"
if {[catch {
    spawn $gbox_binary box cp
    expect {
        -re "Error:.*accepts 2 arg" {
            puts "${GREEN}✓ Found expected error message for missing arguments${NC}"
        }
        -re "Error:.*required" {
            puts "${GREEN}✓ Found expected error message for missing arguments${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for error message${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Error message displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for command completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Test failed: $result${NC}"
    exit 1
}

# Test 2: Box cp command with only one argument (should show error)
puts "\n${YELLOW}Testing box cp command with only one argument...${NC}"
puts "${BLUE}Running Test 2: Box cp command with only one argument${NC}"
if {[catch {
    spawn $gbox_binary box cp local_file
    expect {
        -re "Error:.*accepts 2 arg" {
            puts "${GREEN}✓ Found expected error message for missing destination${NC}"
        }
        -re "Error:.*required" {
            puts "${GREEN}✓ Found expected error message for missing destination${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for error message${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Error message displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for command completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Test failed: $result${NC}"
    exit 1
}

# Test 3: Help command for box cp
puts "\n${YELLOW}Testing help command for box cp...${NC}"
puts "${BLUE}Running Test 3: Help command for box cp${NC}"
if {[catch {
    spawn $gbox_binary box cp --help
    expect {
        -re "Copy files/folders between a box and the local filesystem" {
            puts "${GREEN}✓ Found help description${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for help description${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Help command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        -re "positional arguments:" {
            puts "${GREEN}✓ Found positional arguments section${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for positional arguments section${NC}"
            exit 1
        }
    }
    
    expect {
        -re "src.*Source path" {
            puts "${GREEN}✓ Found src argument description${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for src argument description${NC}"
            exit 1
        }
    }
    
    expect {
        -re "dst.*Destination path" {
            puts "${GREEN}✓ Found dst argument description${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for dst argument description${NC}"
            exit 1
        }
    }
    
    expect {
        -re "Example:" {
            puts "${GREEN}✓ Found Example section${NC}"
            exp_continue
        }
        eof {
            puts "${GREEN}✓ Help command completed successfully${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for help completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Help test failed: $result${NC}"
    exit 1
}

# Test 4: Invalid box path format (both paths are local)
puts "\n${YELLOW}Testing invalid box path format (both paths are local)...${NC}"
puts "${BLUE}Running Test 4: Invalid box path format (both paths are local)${NC}"
if {[catch {
    spawn $gbox_binary box cp local_file1 local_file2
    expect {
        -re "invalid path format" {
            puts "${GREEN}✓ Found expected error for invalid path format${NC}"
        }
        -re "One path must be a box path" {
            puts "${GREEN}✓ Found expected error for invalid path format${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for invalid path format error${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Invalid path format command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Invalid path format error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for invalid path format completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Invalid path format test failed: $result${NC}"
    exit 1
}

# Test 5: Invalid box path format (both paths are box paths)
puts "\n${YELLOW}Testing invalid box path format (both paths are box paths)...${NC}"
puts "${BLUE}Running Test 5: Invalid box path format (both paths are box paths)${NC}"
if {[catch {
    spawn $gbox_binary box cp $test_box_id:/path1 $test_box_id:/path2
    expect {
        -re "invalid path format" {
            puts "${GREEN}✓ Found expected error for invalid path format${NC}"
        }
        -re "One path must be a box path" {
            puts "${GREEN}✓ Found expected error for invalid path format${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for invalid path format error${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Invalid path format command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Invalid path format error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for invalid path format completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Invalid path format test failed: $result${NC}"
    exit 1
}

# Test 6: Invalid box path format (malformed box path)
puts "\n${YELLOW}Testing invalid box path format (malformed box path)...${NC}"
puts "${BLUE}Running Test 6: Invalid box path format (malformed box path)${NC}"
if {[catch {
    spawn $gbox_binary box cp invalid-box-path local_file
    expect {
        -re "invalid path format" {
            puts "${GREEN}✓ Found expected error for malformed box path${NC}"
        }
        -re "invalid box path format" {
            puts "${GREEN}✓ Found expected error for malformed box path${NC}"
        }
        -re "should be BOX_ID:PATH" {
            puts "${GREEN}✓ Found expected error for malformed box path${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for malformed box path error${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Malformed box path command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Malformed box path error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for malformed box path completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Malformed box path test failed: $result${NC}"
    exit 1
}

# Test 7: Copy from local to box (non-existent source file)
puts "\n${YELLOW}Testing copy from local to box (non-existent source file)...${NC}"
puts "${BLUE}Running Test 7: Copy from local to box (non-existent source file)${NC}"
if {[catch {
    spawn $gbox_binary box cp non_existent_file $test_box_id:/tmp/
    expect {
        -re "source file or directory does not exist" {
            puts "${GREEN}✓ Found expected error for non-existent source file${NC}"
        }
        -re "failed to resolve box ID" {
            puts "${GREEN}✓ Found expected box ID resolution error${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for non-existent source file error${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Non-existent source file command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Non-existent source file error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for non-existent source file completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Non-existent source file test failed: $result${NC}"
    exit 1
}

# Test 8: Copy from box to local (invalid box ID)
puts "\n${YELLOW}Testing copy from box to local (invalid box ID)...${NC}"
puts "${BLUE}Running Test 8: Copy from box to local (invalid box ID)${NC}"
if {[catch {
    spawn $gbox_binary box cp invalid-box-id:/tmp/file local_file
    expect {
        -re "failed to resolve box ID" {
            puts "${GREEN}✓ Found expected error for invalid box ID${NC}"
        }
        -re "failed to download from box" {
            puts "${GREEN}✓ Found expected error for invalid box ID${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for invalid box ID error${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Invalid box ID command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Invalid box ID error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for invalid box ID completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Invalid box ID test failed: $result${NC}"
    exit 1
}

# Test 9: Copy from local to box (valid format, but API may not be available)
puts "\n${YELLOW}Testing copy from local to box (valid format)...${NC}"
puts "${BLUE}Running Test 9: Copy from local to box (valid format)${NC}"

# Create a temporary test file
set test_file "/tmp/gbox_test_file.txt"
if {[catch {
    exec echo "Hello World" > $test_file
    puts "${GREEN}✓ Created test file: $test_file${NC}"
} result]} {
    puts "${YELLOW}⚠ Failed to create test file: $result${NC}"
    set test_file ""
}

if {$test_file != ""} {
    if {[catch {
        spawn $gbox_binary box cp $test_file $test_box_id:/tmp/
        expect {
            -re "Copied from.*to box" {
                puts "${GREEN}✓ Found copy success message${NC}"
            }
            -re "failed to upload to box" {
                puts "${GREEN}✓ Found expected upload error (API not available)${NC}"
            }
            -re "failed to resolve box ID" {
                puts "${GREEN}✓ Found expected box ID resolution error${NC}"
            }
            timeout {
                puts "${RED}✗ Timeout waiting for copy operation${NC}"
                exit 1
            }
            eof {
                puts "${RED}✗ Copy command exited unexpectedly${NC}"
                exit 1
            }
        }
        
        expect {
            eof {
                puts "${GREEN}✓ Copy command completed${NC}"
            }
            timeout {
                puts "${RED}✗ Timeout waiting for copy completion${NC}"
                exit 1
            }
        }
        
        catch {close}
    } result]} {
        puts "${RED}✗ Copy from local to box test failed: $result${NC}"
        exit 1
    }
    
    # Clean up test file
    if {[catch {
        exec rm -f $test_file
        puts "${GREEN}✓ Cleaned up test file${NC}"
    } result]} {
        puts "${YELLOW}⚠ Failed to clean up test file: $result${NC}"
    }
} else {
    puts "${YELLOW}⚠ Skipping copy test due to test file creation failure${NC}"
}

# Test 10: Copy from box to local (valid format, but API may not be available)
puts "\n${YELLOW}Testing copy from box to local (valid format)...${NC}"
puts "${BLUE}Running Test 10: Copy from box to local (valid format)${NC}"
if {[catch {
    spawn $gbox_binary box cp $test_box_id:/tmp/file /tmp/gbox_downloaded_file
    expect {
        -re "Copied from box.*to" {
            puts "${GREEN}✓ Found copy success message${NC}"
        }
        -re "failed to download from box" {
            puts "${GREEN}✓ Found expected download error (API not available)${NC}"
        }
        -re "failed to resolve box ID" {
            puts "${GREEN}✓ Found expected box ID resolution error${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for copy operation${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Copy command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Copy command completed${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for copy completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Copy from box to local test failed: $result${NC}"
    exit 1
}

# Test 11: Copy from box to stdout (tar stream)
puts "\n${YELLOW}Testing copy from box to stdout (tar stream)...${NC}"
puts "${BLUE}Running Test 11: Copy from box to stdout (tar stream)${NC}"
if {[catch {
    spawn $gbox_binary box cp $test_box_id:/tmp/file -
    expect {
        -re "failed to download from box" {
            puts "${GREEN}✓ Found expected download error for stdout (API not available)${NC}"
        }
        -re "failed to resolve box ID" {
            puts "${GREEN}✓ Found expected box ID resolution error for stdout${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for stdout copy operation${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Stdout copy command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Stdout copy command completed${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for stdout copy completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Stdout copy test failed: $result${NC}"
    exit 1
}

# Test 12: Copy from stdin to box (tar stream) - Skip this test as it requires interactive input
puts "\n${YELLOW}Testing copy from stdin to box (tar stream)...${NC}"
puts "${BLUE}Running Test 12: Copy from stdin to box (tar stream) - SKIPPED${NC}"
puts "${YELLOW}⚠ Skipping stdin test as it requires interactive input and may hang${NC}"

# Test 13: Copy with complex box path (nested directories)
puts "\n${YELLOW}Testing copy with complex box path (nested directories)...${NC}"
puts "${BLUE}Running Test 13: Copy with complex box path (nested directories)${NC}"
if {[catch {
    spawn $gbox_binary box cp $test_box_id:/var/log/app/error.log /tmp/error.log
    expect {
        -re "Copied from box.*to" {
            puts "${GREEN}✓ Found copy success message for complex path${NC}"
        }
        -re "failed to download from box" {
            puts "${GREEN}✓ Found expected download error for complex path (API not available)${NC}"
        }
        -re "failed to resolve box ID" {
            puts "${GREEN}✓ Found expected box ID resolution error for complex path${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for complex path copy operation${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Complex path copy command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Complex path copy command completed${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for complex path copy completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Complex path copy test failed: $result${NC}"
    exit 1
}

# Test 14: Copy with special characters in paths
puts "\n${YELLOW}Testing copy with special characters in paths...${NC}"
puts "${BLUE}Running Test 14: Copy with special characters in paths${NC}"
if {[catch {
    spawn $gbox_binary box cp $test_box_id:/tmp/file\ with\ spaces.txt /tmp/file_with_spaces.txt
    expect {
        -re "Copied from box.*to" {
            puts "${GREEN}✓ Found copy success message for special characters${NC}"
        }
        -re "failed to download from box" {
            puts "${GREEN}✓ Found expected download error for special characters (API not available)${NC}"
        }
        -re "failed to resolve box ID" {
            puts "${GREEN}✓ Found expected box ID resolution error for special characters${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for special characters copy operation${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Special characters copy command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Special characters copy command completed${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for special characters copy completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Special characters copy test failed: $result${NC}"
    exit 1
}

# Test 15: Copy with multiple arguments (should show error)
puts "\n${YELLOW}Testing copy with multiple arguments (should show error)...${NC}"
puts "${BLUE}Running Test 15: Copy with multiple arguments (should show error)${NC}"
if {[catch {
    spawn $gbox_binary box cp file1 file2 file3
    expect {
        -re "Error:.*accepts 2 arg" {
            puts "${GREEN}✓ Found expected error for multiple arguments${NC}"
        }
        -re "Error:.*too many" {
            puts "${GREEN}✓ Found expected error for multiple arguments${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for multiple arguments error${NC}"
            exit 1
        }
        eof {
            puts "${RED}✗ Multiple arguments command exited unexpectedly${NC}"
            exit 1
        }
    }
    
    expect {
        eof {
            puts "${GREEN}✓ Multiple arguments error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for multiple arguments completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Multiple arguments test failed: $result${NC}"
    exit 1
}

# Clean up: terminate the test box if it was created
if {$test_box_id != "test-box-placeholder" && $test_box_id != ""} {
    puts "\n${YELLOW}Cleaning up test box: $test_box_id${NC}"
    if {[catch {
        spawn $gbox_binary box terminate $test_box_id
        expect {
            -re "Box terminated successfully" {
                puts "${GREEN}✓ Test box terminated successfully${NC}"
            }
            -re "failed to terminate box" {
                puts "${YELLOW}⚠ Failed to terminate test box (may not exist)${NC}"
            }
            timeout {
                puts "${YELLOW}⚠ Timeout waiting for box termination${NC}"
            }
            eof {
                puts "${GREEN}✓ Box terminate command completed${NC}"
            }
        }
        
        expect {
            eof {
                puts "${GREEN}✓ Box terminate command finished${NC}"
            }
            timeout {
                puts "${YELLOW}⚠ Timeout waiting for terminate completion${NC}"
            }
        }
        
        catch {close}
    } result]} {
        puts "${YELLOW}⚠ Box cleanup failed: $result${NC}"
    }
} else {
    puts "\n${YELLOW}No test box to clean up (used placeholder)${NC}"
}

puts "\n${GREEN}All box cp tests passed successfully!${NC}"
exit 0
