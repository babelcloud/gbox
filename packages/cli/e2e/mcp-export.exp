#!/usr/bin/env expect

# Exit codes:
#   0 - Test passed
#   1 - Test failed

# Set timeout for command execution
set timeout 30

# Colors for output
set GREEN "\033\[0;32m"
set RED "\033\[0;31m"
set YELLOW "\033\[1;33m"
set BLUE "\033\[0;34m"
set NC "\033\[0m"

# Get the gbox binary path
# Default to using the built binary in the parent directory
set gbox_binary "../gbox"

# If the built binary doesn't exist, fall back to system gbox
if {![file exists $gbox_binary]} {
    set gbox_binary "gbox"
}

puts "${BLUE}Testing gbox mcp export command...${NC}"

# Test 1: Help command
puts "\n${YELLOW}Testing help command...${NC}"
if {[catch {
    spawn $gbox_binary mcp export --help
    set description_found 0
    set usage_found 0
    set example_found 0
    
    expect {
        -re "Export MCP configuration for Claude Desktop/Cursor" {
            puts "${GREEN}✓ Found export command description${NC}"
            set description_found 1
            exp_continue
        }
        -re "Usage:" {
            puts "${GREEN}✓ Found Usage section${NC}"
            set usage_found 1
            exp_continue
        }
        -re "Example:" {
            puts "${GREEN}✓ Found Example section${NC}"
            set example_found 1
            exp_continue
        }
        -re "gbox mcp export --merge-to claude" {
            puts "${GREEN}✓ Found example command${NC}"
            exp_continue
        }
        eof {
            puts "${GREEN}✓ Help command completed successfully${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for help output${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Help test failed: $result${NC}"
    exit 1
}

# Test 2: Short help flag
puts "\n${YELLOW}Testing short help flag...${NC}"
if {[catch {
    spawn $gbox_binary mcp export -h
    expect {
        -re "Export MCP configuration for Claude Desktop/Cursor" {
            puts "${GREEN}✓ Found export command description with short flag${NC}"
            exp_continue
        }
        eof {
            puts "${GREEN}✓ Short help command completed successfully${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for short help completion${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Short help test failed: $result${NC}"
    exit 1
}

# Test 3: Basic export without merge-to (should show JSON output)
puts "\n${YELLOW}Testing basic export without merge-to...${NC}"
set json_found 0
set mcpServers_found 0
set gbox_android_found 0
set instructions_found 0

spawn $gbox_binary mcp export

expect {
    -re "mcpServers" {
        puts "${GREEN}✓ Found mcpServers key${NC}"
        set mcpServers_found 1
        exp_continue
    }
    -re "gbox-android" {
        puts "${GREEN}✓ Found gbox-android server${NC}"
        set gbox_android_found 1
        exp_continue
    }
    -re "\\\{" {
        puts "${GREEN}✓ Found JSON output start${NC}"
        set json_found 1
        exp_continue
    }
    -re "To merge this configuration" {
        puts "${GREEN}✓ Found merge instructions${NC}"
        set instructions_found 1
        exp_continue
    }
    eof {
        if {$json_found && $mcpServers_found && $gbox_android_found && $instructions_found} {
            puts "${GREEN}✓ Basic export test completed successfully${NC}"
        } else {
            puts "${RED}✗ Missing expected output elements${NC}"
            puts "${RED}  json_found: $json_found${NC}"
            puts "${RED}  mcpServers_found: $mcpServers_found${NC}"
            puts "${RED}  gbox_android_found: $gbox_android_found${NC}"
            puts "${RED}  instructions_found: $instructions_found${NC}"
            exit 1
        }
    }
    timeout {
        puts "${RED}✗ Timeout waiting for export output${NC}"
        exit 1
    }
}

catch {close} 

# Test 4: Dry run with claude merge-to
puts "\n${YELLOW}Testing dry run with claude merge-to...${NC}"
if {[catch {
    spawn $gbox_binary mcp export --merge-to claude --dry-run
    set json_found 0
    set mcpServers_found 0
    set gbox_android_found 0
    
    expect {
        -re "mcpServers" {
            puts "${GREEN}✓ Found mcpServers in dry run${NC}"
            set mcpServers_found 1
            exp_continue
        }
        -re "gbox-android" {
            puts "${GREEN}✓ Found gbox-android in dry run${NC}"
            set gbox_android_found 1
            exp_continue
        }
        -re "\\\{" {
            puts "${GREEN}✓ Found JSON output in dry run${NC}"
            set json_found 1
            exp_continue
        }
        eof {
            if {$json_found && $mcpServers_found && $gbox_android_found} {
                puts "${GREEN}✓ Dry run test completed successfully${NC}"
            } else {
                puts "${RED}✗ Missing expected dry run output${NC}"
                exit 1
            }
        }
        timeout {
            puts "${RED}✗ Timeout waiting for dry run output${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Dry run test failed: $result${NC}"
    exit 1
}

# Test 5: Dry run with cursor merge-to
puts "\n${YELLOW}Testing dry run with cursor merge-to...${NC}"
if {[catch {
    spawn $gbox_binary mcp export --merge-to cursor --dry-run
    set json_found 0
    set mcpServers_found 0
    set gbox_android_found 0
    
    expect {
        -re "mcpServers" {
            puts "${GREEN}✓ Found mcpServers in cursor dry run${NC}"
            set mcpServers_found 1
            exp_continue
        }
        -re "gbox-android" {
            puts "${GREEN}✓ Found gbox-android in cursor dry run${NC}"
            set gbox_android_found 1
            exp_continue
        }
        -re "\\\{" {
            puts "${GREEN}✓ Found JSON output in cursor dry run${NC}"
            set json_found 1
            exp_continue
        }
        eof {
            if {$json_found && $mcpServers_found && $gbox_android_found} {
                puts "${GREEN}✓ Cursor dry run test completed successfully${NC}"
            } else {
                puts "${RED}✗ Missing expected cursor dry run output${NC}"
                exit 1
            }
        }
        timeout {
            puts "${RED}✗ Timeout waiting for cursor dry run output${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Cursor dry run test failed: $result${NC}"
    exit 1
}

# Test 6: Dry run with claude-code merge-to (user scope)
puts "\n${YELLOW}Testing dry run with claude-code merge-to (user scope)...${NC}"
if {[catch {
    spawn $gbox_binary mcp export --merge-to claude-code --dry-run --scope user
    set command_found 0
    set claude_mcp_found 0
    set gbox_android_found 0
    set npx_found 0
    
    expect {
        -re "Copy and execute the following command" {
            puts "${GREEN}✓ Found command instruction${NC}"
            set command_found 1
            exp_continue
        }
        -re "claude mcp add" {
            puts "${GREEN}✓ Found claude mcp add command${NC}"
            set claude_mcp_found 1
            exp_continue
        }
        -re "gbox-android" {
            puts "${GREEN}✓ Found gbox-android server name${NC}"
            set gbox_android_found 1
            exp_continue
        }
        -re "npx.*@gbox.ai/mcp-server@latest" {
            puts "${GREEN}✓ Found npx command with package@latest${NC}"
            set npx_found 1
            exp_continue
        }
        eof {
            if {$command_found && $claude_mcp_found && $gbox_android_found && $npx_found} {
                puts "${GREEN}✓ Claude-code dry run test completed successfully${NC}"
            } else {
                puts "${RED}✗ Missing expected claude-code dry run output${NC}"
                exit 1
            }
        }
        timeout {
            puts "${RED}✗ Timeout waiting for claude-code dry run output${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Claude-code dry run test failed: $result${NC}"
    exit 1
}

# Test 7: Dry run with claude-code merge-to (project scope)
puts "\n${YELLOW}Testing dry run with claude-code merge-to (project scope)...${NC}"
if {[catch {
    spawn $gbox_binary mcp export --merge-to claude-code --dry-run --scope project
    set command_found 0
    set claude_mcp_found 0
    set project_scope_found 0
    
    expect {
        -re "Copy and execute the following command" {
            puts "${GREEN}✓ Found command instruction for project scope${NC}"
            set command_found 1
            exp_continue
        }
        -re "claude mcp add" {
            puts "${GREEN}✓ Found claude mcp add command for project scope${NC}"
            set claude_mcp_found 1
            exp_continue
        }
        -re "-s project" {
            puts "${GREEN}✓ Found project scope parameter${NC}"
            set project_scope_found 1
            exp_continue
        }
        eof {
            if {$command_found && $claude_mcp_found && $project_scope_found} {
                puts "${GREEN}✓ Project scope dry run test completed successfully${NC}"
            } else {
                puts "${RED}✗ Missing expected project scope output${NC}"
                exit 1
            }
        }
        timeout {
            puts "${RED}✗ Timeout waiting for project scope output${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Project scope dry run test failed: $result${NC}"
    exit 1
}

# Test 8: Dry run with claude-code merge-to (local scope)
puts "\n${YELLOW}Testing dry run with claude-code merge-to (local scope)...${NC}"
if {[catch {
    spawn $gbox_binary mcp export --merge-to claude-code --dry-run --scope local
    set command_found 0
    set claude_mcp_found 0
    set local_scope_found 0
    
    expect {
        -re "Copy and execute the following command" {
            puts "${GREEN}✓ Found command instruction for local scope${NC}"
            set command_found 1
            exp_continue
        }
        -re "claude mcp add" {
            puts "${GREEN}✓ Found claude mcp add command for local scope${NC}"
            set claude_mcp_found 1
            exp_continue
        }
        -re "-s local" {
            puts "${GREEN}✓ Found local scope parameter${NC}"
            set local_scope_found 1
            exp_continue
        }
        eof {
            if {$command_found && $claude_mcp_found && $local_scope_found} {
                puts "${GREEN}✓ Local scope dry run test completed successfully${NC}"
            } else {
                puts "${RED}✗ Missing expected local scope output${NC}"
                exit 1
            }
        }
        timeout {
            puts "${RED}✗ Timeout waiting for local scope output${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Local scope dry run test failed: $result${NC}"
    exit 1
}

# Test 9: Invalid merge-to target
puts "\n${YELLOW}Testing invalid merge-to target...${NC}"
if {[catch {
    spawn $gbox_binary mcp export --merge-to invalid-target
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for invalid merge-to target${NC}"
        }
        -re "must be either 'claude', 'cursor', or 'claude-code'" {
            puts "${GREEN}✓ Found expected error message for invalid target${NC}"
        }
        eof {
            puts "${GREEN}✓ Invalid merge-to target error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for invalid merge-to error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Invalid merge-to target test failed: $result${NC}"
    exit 1
}

# Test 10: Invalid scope for claude-code
puts "\n${YELLOW}Testing invalid scope for claude-code...${NC}"
if {[catch {
    spawn $gbox_binary mcp export --merge-to claude-code --scope invalid-scope
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for invalid scope${NC}"
        }
        -re "invalid scope" {
            puts "${GREEN}✓ Found expected error message for invalid scope${NC}"
        }
        eof {
            puts "${GREEN}✓ Invalid scope error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for invalid scope error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Invalid scope test failed: $result${NC}"
    exit 1
}

# Test 11: Test with extra arguments (should show error)
puts "\n${YELLOW}Testing with extra arguments...${NC}"
if {[catch {
    spawn $gbox_binary mcp export extra-arg
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for extra arguments${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Extra arguments error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for extra arguments error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Extra arguments test failed: $result${NC}"
    exit 1
}

# Test 12: Test with multiple extra arguments
puts "\n${YELLOW}Testing with multiple extra arguments...${NC}"
if {[catch {
    spawn $gbox_binary mcp export arg1 arg2 arg3
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for multiple extra arguments${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Multiple extra arguments error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for multiple extra arguments error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Multiple extra arguments test failed: $result${NC}"
    exit 1
}

# Test 13: Test with empty string argument
puts "\n${YELLOW}Testing with empty string argument...${NC}"
if {[catch {
    spawn $gbox_binary mcp export ""
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for empty string argument${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Empty string argument error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for empty string argument error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Empty string argument test failed: $result${NC}"
    exit 1
}

# Test 14: Test with special characters in arguments
puts "\n${YELLOW}Testing with special characters in arguments...${NC}"
if {[catch {
    spawn $gbox_binary mcp export "special!@#$%^&*()"
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for special characters${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Special characters error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for special characters error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Special characters test failed: $result${NC}"
    exit 1
}

# Test 15: Test with spaces in arguments
puts "\n${YELLOW}Testing with spaces in arguments...${NC}"
if {[catch {
    spawn $gbox_binary mcp export "arg with spaces"
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for spaces in arguments${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Spaces in arguments error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for spaces in arguments error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Spaces in arguments test failed: $result${NC}"
    exit 1
}

# Test 16: Test with numeric arguments
puts "\n${YELLOW}Testing with numeric arguments...${NC}"
if {[catch {
    spawn $gbox_binary mcp export 12345
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for numeric arguments${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Numeric arguments error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for numeric arguments error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Numeric arguments test failed: $result${NC}"
    exit 1
}

# Test 17: Test with very long argument
puts "\n${YELLOW}Testing with very long argument...${NC}"
if {[catch {
    set long_arg "very-long-argument-that-exceeds-normal-length-and-should-still-work-properly-1234567890abcdefghijklmnopqrstuvwxyz"
    spawn $gbox_binary mcp export $long_arg
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for long argument${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Long argument error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for long argument error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Long argument test failed: $result${NC}"
    exit 1
}

# Test 18: MCP command help (parent command)
puts "\n${YELLOW}Testing MCP command help...${NC}"
if {[catch {
    spawn $gbox_binary mcp --help
    set description_found 0
    set commands_found 0
    set export_found 0
    
    expect {
        -re "MCP operations" {
            puts "${GREEN}✓ Found MCP command description${NC}"
            set description_found 1
            exp_continue
        }
        -re "Available Commands:" {
            puts "${GREEN}✓ Found Available Commands section${NC}"
            set commands_found 1
            exp_continue
        }
        -re "export.*Export MCP configuration" {
            puts "${GREEN}✓ Found export command in help output${NC}"
            set export_found 1
            exp_continue
        }
        eof {
            puts "${GREEN}✓ MCP help command completed successfully${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for MCP help output${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ MCP help test failed: $result${NC}"
    exit 1
}

# Test 19: Test with newlines in argument
puts "\n${YELLOW}Testing with newlines in argument...${NC}"
if {[catch {
    spawn $gbox_binary mcp export "arg\nwith\nnewlines"
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for newlines in argument${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Newlines in argument error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for newlines in argument error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Newlines in argument test failed: $result${NC}"
    exit 1
}

# Test 20: Test with tabs in argument
puts "\n${YELLOW}Testing with tabs in argument...${NC}"
if {[catch {
    spawn $gbox_binary mcp export "arg\twith\ttabs"
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for tabs in argument${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Tabs in argument error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for tabs in argument error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Tabs in argument test failed: $result${NC}"
    exit 1
}

# Test 21: Test with only special characters in argument
puts "\n${YELLOW}Testing with only special characters in argument...${NC}"
if {[catch {
    spawn $gbox_binary mcp export "!@#$%^&*()"
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for special characters only${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ Special characters only error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for special characters only error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Special characters only test failed: $result${NC}"
    exit 1
}

# Test 22: Test with UUID-like argument
puts "\n${YELLOW}Testing with UUID-like argument...${NC}"
if {[catch {
    spawn $gbox_binary mcp export "123e4567-e89b-12d3-a456-426614174000"
    expect {
        -re "Error:" {
            puts "${GREEN}✓ Found expected error for UUID-like argument${NC}"
        }
        -re "unknown command" {
            puts "${GREEN}✓ Found expected unknown command error${NC}"
        }
        -re "too many arguments" {
            puts "${GREEN}✓ Found expected too many arguments error${NC}"
        }
        eof {
            puts "${GREEN}✓ UUID-like argument error displayed correctly${NC}"
        }
        timeout {
            puts "${RED}✗ Timeout waiting for UUID-like argument error${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ UUID-like argument test failed: $result${NC}"
    exit 1
}

# Test 23: Test short flags combination
puts "\n${YELLOW}Testing short flags combination...${NC}"
if {[catch {
    spawn $gbox_binary mcp export -m claude -d
    set json_found 0
    set mcpServers_found 0
    set gbox_android_found 0
    
    expect {
        -re "mcpServers" {
            puts "${GREEN}✓ Found mcpServers with short flags${NC}"
            set mcpServers_found 1
            exp_continue
        }
        -re "gbox-android" {
            puts "${GREEN}✓ Found gbox-android with short flags${NC}"
            set gbox_android_found 1
            exp_continue
        }
        -re "\\\{" {
            puts "${GREEN}✓ Found JSON output with short flags${NC}"
            set json_found 1
            exp_continue
        }
        eof {
            if {$json_found && $mcpServers_found && $gbox_android_found} {
                puts "${GREEN}✓ Short flags combination test completed successfully${NC}"
            } else {
                puts "${RED}✗ Missing expected short flags output${NC}"
                exit 1
            }
        }
        timeout {
            puts "${RED}✗ Timeout waiting for short flags output${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Short flags combination test failed: $result${NC}"
    exit 1
}

# Test 24: Test claude-code with short flags
puts "\n${YELLOW}Testing claude-code with short flags...${NC}"
if {[catch {
    spawn $gbox_binary mcp export -m claude-code -d -s user
    set command_found 0
    set claude_mcp_found 0
    set gbox_android_found 0
    set npx_found 0
    
    expect {
        -re "Copy and execute the following command" {
            puts "${GREEN}✓ Found command instruction with short flags${NC}"
            set command_found 1
            exp_continue
        }
        -re "claude mcp add" {
            puts "${GREEN}✓ Found claude mcp add command with short flags${NC}"
            set claude_mcp_found 1
            exp_continue
        }
        -re "gbox-android" {
            puts "${GREEN}✓ Found gbox-android server name with short flags${NC}"
            set gbox_android_found 1
            exp_continue
        }
        -re "npx.*@gbox.ai/mcp-server@latest" {
            puts "${GREEN}✓ Found npx command with package@latest using short flags${NC}"
            set npx_found 1
            exp_continue
        }
        eof {
            if {$command_found && $claude_mcp_found && $gbox_android_found && $npx_found} {
                puts "${GREEN}✓ Claude-code short flags test completed successfully${NC}"
            } else {
                puts "${RED}✗ Missing expected claude-code short flags output${NC}"
                exit 1
            }
        }
        timeout {
            puts "${RED}✗ Timeout waiting for claude-code short flags output${NC}"
            exit 1
        }
    }
    
    catch {close}
} result]} {
    puts "${RED}✗ Claude-code short flags test failed: $result${NC}"
    exit 1
}

puts "\n${GREEN}All mcp export tests passed successfully!${NC}"
exit 0
