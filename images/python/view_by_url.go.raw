package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	"github.com/chromedp/chromedp"
)

// Output represents the JSON output structure
type Output struct {
	URL           string  `json:"url"`
	ElapsedTime   float64 `json:"elapsed_time_seconds"`
	ContentLength int     `json:"content_length_bytes"`
	OutputFile    string  `json:"output_file"`
}

func main() {
	// Check if URL is provided as command line argument
	if len(os.Args) < 2 {
		fmt.Println("Usage: view_by_url <url>")
		os.Exit(1)
	}

	url := os.Args[1]
	startTime := time.Now()

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Create headless browser options
	opts := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Flag("headless", true),
		chromedp.Flag("disable-gpu", true),
		chromedp.Flag("no-sandbox", true),
		chromedp.Flag("disable-dev-shm-usage", true),
		// Specify the path to Chromium explicitly
		chromedp.ExecPath("/usr/bin/chromium"),
	)
	allocCtx, cancel := chromedp.NewExecAllocator(ctx, opts...)
	defer cancel()

	// Create browser context with logging
	taskCtx, cancel := chromedp.NewContext(allocCtx, chromedp.WithLogf(log.Printf))
	defer cancel()

	// Variable to store the HTML content
	var htmlContent string

	// Create tasks to navigate to page and extract HTML
	err := chromedp.Run(taskCtx,
		chromedp.Navigate(url),
		chromedp.OuterHTML("html", &htmlContent),
	)

	elapsedTime := time.Since(startTime)

	if err != nil {
		log.Fatalf("Error running chromedp tasks: %v", err)
	}

	// Create the output directory if it doesn't exist
	outputDir := "/var/gbox"
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatalf("Error creating output directory: %v", err)
	}

	// Generate a filename based on the URL and timestamp
	timestamp := time.Now().Format("20060102_150405")
	filename := filepath.Join(outputDir, fmt.Sprintf("page_%s.html", timestamp))

	// Write the HTML content to file
	if err := os.WriteFile(filename, []byte(htmlContent), 0644); err != nil {
		log.Fatalf("Error writing HTML file: %v", err)
	}

	// Create output structure
	output := Output{
		URL:           url,
		ElapsedTime:   elapsedTime.Seconds(),
		ContentLength: len(htmlContent),
		OutputFile:    filename,
	}

	// Marshal the output to JSON with indentation
	jsonOutput, err := json.MarshalIndent(output, "", "  ")
	if err != nil {
		log.Fatalf("Error marshaling JSON: %v", err)
	}

	// Print the JSON output
	fmt.Println(string(jsonOutput))
}
